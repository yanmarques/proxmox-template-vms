#!/bin/sh
set -e

# global vars
openbsd_dev=sd0
linux_dev=sda

if [ $# -ne 1 ]; then
	echo "Usage: $0 USER"
	exit 1
fi	

# input argument
user="$1"

function openbsd_disks_count {
	sysctl hw.disknames | tr ',' '\n' | egrep '(sd|wd)[0-9]{1}\:' | wc -l
}

function linux_disks_count {
	fdisk -l | egrep 'Disk (sd|hd)[a-z]{1}' | wc -l
}

function linux_start_disk {
	local device="$1"
	local block_dev=/dev/"$device"

	# is the block device already formatted?
	# no, so format it and configure it's contents
	if ! blkid "$block_dev" > /dev/null; then
		echo 'type=83' | sfdisk "$block_dev"
		mkfs.ext4 "$block_dev"1
		mkdir -p /rw/
		mount "$block_dev"1 /rw/
		setup_vm_disk /bin/bash
	else
		mkdir -p /rw/
		mount "$block_dev"1 /rw/
	fi
}

function many_str {
	local str="$1"
	local count="$2"

	printf '%*s' "$count" | tr ' ' "$str"
}

function openbsd_start_disk {
	# represents an empty disk uid, seventeen zeros
	local empty_duid="$(many_str 0 17)"

	local device="$1"
	
	# whole disk
	local char_dev_disk=/dev/r"$device"c

	# root partition
	local char_dev_root=/dev/r"$device"a
	
	# block device
	local block_dev_root=/dev/"$device"a

	# grab device uid
	local duid="$(disklabel $device | grep duid | awk -F: '{print $2}' | tr -d ' ')"

	# deduce whether disk needs a partition table initialization
	if [ "$duid" == "$empty_duid" ]; then
		fdisk -iy "$char_dev_disk"
		disklabel -Aw "$char_dev_disk"
		newfs "$char_dev_root"
		mkdir -p /rw/
		mount "$block_dev_root" /rw/
		setup_vm_disk /bin/ksh
	else
		mkdir -p /rw/
		mount "$block_dev_root" /rw/
	fi
}

# configures default files on client disk
function setup_vm_disk {
	local binary="$1"

	# create user home directory
	mkdir -p /rw/home
	cp -r /etc/skel/ /rw/home/"$user"	
	chown -R "$user":"$user" /rw/home/"$user"

	# maybe restore SELinux security context
	if command -v restorecon > /dev/null 2>&1; then
		restorecon -R /rw/home
	fi

	# configuration files
	# gives user full control over the installation
	mkdir -p /rw/config
	mkdir -p /rw/binds

	if [ ! -f /rw/config/rc.local ]; then
		cat <<EOF > /rw/config/rc.local
#!$binary
# Put commands to execute with systemd service.
# Eg.: systemctl start openvpn-client
EOF
	fi
}

# given a root directory, mount every file to the root filesystem
#
# imagine the following file structure:
# /rw/binds
# └── etc
#     └── wireguard
#         └── wg0.conf
#
# now, the file /rw/binds/etc/wireguard/wg0.conf would be
# mounted at /etc/wireguard/wg0.conf
# 
function bind_files {
	for file in "$(ls $1)"; do
		# avoid an infinite loop
		if [ -z "$file" ]; then
			break
		fi

		local path="${1%/}/$file"
		if [ -d "$path" ]; then
		       bind_files "$path"
	    else
			local target_file="${path#/rw/binds}"

			# ensure it is an absolute path to the filesystem
			target_file="/${target_file#/}"

			# ensure directory exists
			mkdir -p "$(dirname $target_file)"

			# then copy it
			cp -p "$path" "$target_file"
		fi    
	done
}

# execute this at startup
function handle_user_config {
	bind_files /rw/binds
	/rw/config/rc.local
}

case "$(uname)" in
	OpenBSD)
		if [ "$(openbsd_disks_count)" -lt 2 ]; then
			exit 0
		fi

		openbsd_start_disk "$openbsd_dev"

		umount /home/
		ln -s /rw/home/ /home/

		;;
	*)
		if [ "$(linux_disks_count)" -lt 2 ]; then
			exit 0
		fi

		linux_start_disk "$linux_dev"

		mount --bind /rw/home/ /home/

		;;
esac

handle_user_config
