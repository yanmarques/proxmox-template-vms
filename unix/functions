#!/bin/sh

# shellcheck shell=bash

unset user

#################################################
# Environment vars
#################################################

# rw directorty var
rw_dir=${TEMPLATED_RW_DIR:-/rw}
rw_dir=${rw_dir%/}

# skeleton directory for user
skel_dir=${TEMPLATED_SKEL_DIR:-/etc/skel}
skel_dir=${skel_dir%/}

# base home directory
base_home_dir=${TEMPLATED_BASE_HOME_DIR:-/home}
base_home_dir=${base_home_dir%/}

# default binary used on rc script
default_binary=${TEMPLATED_BINARY:-/bin/bash}
default_binary=${default_binary%/}

# default runtime path where host data is stored
runtime_dir=${TEMPLATED_RUNTIME_DIR:-/var/run/proxmox-templated-vms}
runtime_dir=${runtime_dir%/}

#################################################
# Global vars
#################################################

# host disk uuid
templated_disk_uuid="3f484b83-c07a-4aad-b9b7-39c80cccab0c"


#################################################
# Runtime vars
#################################################

load_runtime_vars() {
	config_dir="$rw_dir"/config
	binds_dir="$rw_dir"/binds
	rc_config="$config_dir"/rc.local
	binds_config="$config_dir"/bind-dirs.conf
}

load_runtime_vars


#################################################
# Error codes
#################################################

# operations on formating a raw disk
# shellcheck disable=SC2034
format_disk_err=5

# file system creation
# shellcheck disable=SC2034
file_system_err=6

# mounting disks
# shellcheck disable=SC2034
mount_err=7

# initial home population with skeleton directory
home_populate_err=8

# when changing user home permissions
change_home_perm_err=9

rw_base_home() {
	# user home directory location on rw device
	echo "$rw_dir""$base_home_dir"
}

fill_skeleton_directory() {
	# shellcheck disable=SC2154
	cp -a "$skel_dir" "$(rw_base_home)"/"$user"
}

fix_user_dir_permission() {
	chown -R "$user" "$(rw_base_home)"/"$user" && \
		chgrp -R "$user" "$(rw_base_home)"/"$user"
}

populate_home_dir() {
	mkdir -p "$(rw_base_home)"

	exec_log "populate home directory from: $skel_dir" \
		fill_skeleton_directory || return "$home_populate_err"

	exec_log "fix home user dir permissions" \
		fix_user_dir_permission || return "$change_home_perm_err"
}

post_home_dir_populated() {
	:
}

# configures default files on client disk
setup_vm_user_data() {
	# create user home directory
	if [ ! -d "$(rw_base_home)" ]; then
		exec_log "home directory initialization" \
			populate_home_dir || return

		exec_log "calling post-home-dir-populated hook" \
			post_home_dir_populated || return
	fi

	# configuration files
	# gives user full control over the installation
	mkdir -p "$config_dir"
	mkdir -p "$binds_dir"

	if [ ! -f "$rc_config" ]; then
		cat <<EOF > "$rc_config"
#!$default_binary
# Put commands to execute with systemd service.
# Eg.: systemctl start openvpn-client
EOF
		chmod 755 "$rc_config"
	fi

	if [ ! -f "$binds_config" ]; then
		touch "$binds_config"
		chmod 644 "$binds_config"
	fi
}

is_directory_bind() {
	local directory sufix_transform sufix_and_prefix
	directory="${1:?}"
	sufix_transform="/${directory#/}"
	sufix_and_prefix="${sufix_transform%/}/"

	grep -e "^$sufix_transform$" -e "^$sufix_and_prefix$" \
		"$binds_config" > /dev/null 2>&1
}

is_empty_directory() {
	local target_dir
	target_dir="${1:?}"

	[ -z "$(ls "$target_dir")" ]
}

# given a root directory, mount every file to the root filesystem
#
# imagine the following file structure:
# /rw/binds
# └── etc
#     └── wireguard
#         └── wg0.conf
#
# now, the file /rw/binds/etc/wireguard/wg0.conf would be
# mounted at /etc/wireguard/wg0.conf
# 
bind_files() {
	local target fake_path
	target="${1:?}"

	# ensure directory
	[ -d "$target" ] || return 1

	# ensure not empty
	is_empty_directory "$target" && return 2

	for path in "$target"/*; do
		if [ -d "$path" ]; then
			fake_path="${path#${binds_dir}}"
			
			if ! is_directory_bind "$fake_path"; then
				# recursive function call when path is a directory
				# and is not registered as a bind
		    	bind_files "$path"
				continue
			fi
		fi

		local_bind_file_object "$path"
	done
}

local_bind_file_object() {
	local path target_file
	path="${1:?}"

	# try to find the real path
	real_path="$(realpath "$path")"
	
	# ensure path exists
	if [ ! -e "$real_path" ]; then
		err "file not found: $path"
		return 1
	fi

	# find the target path to file
	target_file="${real_path#${binds_dir}}"

	# ensure it is an absolute path to the filesystem
	target_file="/${target_file#/}"

	# backup existing content and ensure target_file
	# is not present
	if [ -e "$target_file" ]; then
		exec_log "backup existing target: $target_file" \
			mv --force "$target_file" "${target_file%/}.old" || return "$file_system_err"
	fi

	# call arbitrary mount function to create link
	# between source and target
	exec_log "binding user file" \
		mount_strategy "$real_path" "$target_file"
}

prepare_disk_when_raw() {
	local block_dev
	block_dev="${1:?}"

	# is the block device already formatted?
	# no, so format it and configure it's contents
	if ! is_raw_disk "$block_dev"; then
		return 0
	fi

	# create an ext4 file system on the created partition
	# shellcheck disable=SC2154
	exec_log "create fs on device" make_filesystem "$block_dev" || \
		return "$file_system_err"
}

start_disk() {
	local block_dev

	# block device path
	block_dev="${1:?}"
	
	# shellcheck disable=2086
	prepare_disk_when_raw "$block_dev" || return

	# device mgmt
	check_filesystem "$block_dev" || return

	# ensure mountpoiunt exists then mount
	# shellcheck disable=SC2154
	mkdir -p "$rw_dir"

	# mount device disk on rw directory
	# shellcheck disable=2086
	# shellcheck disable=SC2154
	exec_log "mount device" \
		mount "$block_dev" "$rw_dir" || \
		return "$mount_err"
}

mount_user_home_dir() {
	mount_strategy "$(rw_base_home)" "$base_home_dir"
}

bind_user_files() {
	bind_files "$binds_dir"
	status_code="$?"

	# ignore when binds directory is empty
	[ "$status_code" -eq 2 ] && return 0

	return "$status_code"
}

# execute this at startup
start_user_custom_config() {
	exec_log "binding user files" bind_user_files
	exec_log "calling user rc script" "$rc_config"
}

ensure_formated_and_mounted() {
	local env_device
	env_device="${TEMPLATED_DEV}"

	if [ -n "$env_device" ]; then
		start_disk "$env_device"
		return
	fi

	local uuid uuid_count disk disk_count
	uuid="$(detect_partition)"
	disk="$(detect_raw_disk)"

	# nothing detected
	if [ -z "$disk" ] && [ -z "$uuid" ]; then
		err "any raw disk or partition available"
		return "$format_disk_err"
	fi

	# count lines
	uuid_count="$(wc -l <<< "${uuid}")"
	disk_count="$(wc -l <<< "${disk}")"

	local disk_valid uuid_valid
	disk_valid=false
	uuid_valid=false

	# set whether valid
	[ -n "$disk" ] && [ "$disk_count" -eq 1 ] && disk_valid=true
	[ -n "$uuid" ] && [ "$uuid_count" -eq 1 ] && uuid_valid=true

	if ! $disk_valid && ! $uuid_valid; then
		err "can not proceed, unable to detect with precision which device to use"
		info "ensure that only exists 1 formatted partition or 1 disk"
		return "$format_disk_err"
	fi

	# takes precedence over the raw disk.
	# this is a must, because one should be able to start a template-based 
	# vm with just some raw disk and it ignores these raw disks
	if $uuid_valid; then
		# ensure uuid is valid just getting the device path 
		disk="$(find_device_by_uuid "$uuid")"
		if [ -z "$disk" ]; then
			err "no such partition: $uuid"
			return 1
		fi
	fi
	
	# disk is raw, will use the first partition
	start_disk "$disk"
}

mount_host_data() {
	local device
	device="$(find_device_by_uuid "$templated_disk_uuid")"

	if [ -z "$device" ]; then
		err "failed to receive host data, missing cdrom disk"
		return 1
	fi

	# ensure mountpoint exists
	mkdir -p "$runtime_dir"

	exec_log "mount host disk" mount "$device" "$runtime_dir" || \
		return "$mount_err"
}

host_info_hook() {
	:
}

handle_host_info() {
	if [ -f "$runtime_dir"/hostname ]; then
		exec_log "setting vm hostname" \
			set_hostname "$(< "$runtime_dir"/hostname)" || return
	fi

	exec_log "calling custom host info hook" host_info_hook || return 
}

is_template_vm() {
	[ -f "$runtime_dir"/template-vm ]
}

info() {
	echo "$(date) [INFO] $*"
}

err() {
	echo "$(date) [ERROR] $*" >> /dev/stderr
}

exec_log() {
	local exit_status title fn text
	title="${1:?}"
	fn=${2:?}
	shift
	shift

	text="$title [$fn"

	# only put arguments when present
	if [ $# -ne 0 ]; then
		text+=" $*]"
	else
		text+="]"
	fi

	# call function
	$fn "$@"
	exit_status="$?"

	if [ "$exit_status" -eq 0 ]; then
		info "$text: succeded"
	else
		err "$text: failed"
	fi

	return "$exit_status"
}