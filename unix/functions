#!/bin/sh

# shellcheck shell=bash

unset user

#################################################
# Environment vars
#################################################

# rw directorty var
rw_dir=${TEMPLATED_RW_DIR:-/rw}
rw_dir=${rw_dir%/}

# where log to
log_file="${TEMPLATED_LOG_FILE:-/var/log/templated.log}"

# skeleton directory for user
skel_dir=${TEMPLATED_SKEL_DIR:-/etc/skel}
skel_dir=${skel_dir%/}

# base home directory
base_home_dir=${TEMPLATED_BASE_HOME_DIR:-/home}
base_home_dir=${base_home_dir%/}

# default binary used on rc script
default_binary=${TEMPLATED_BINARY:-/bin/bash}
default_binary=${base_home_dir%/}


#################################################
# Error codes
#################################################

# operations on formating a raw disk
# shellcheck disable=SC2034
format_disk_err=5

# file system creation
# shellcheck disable=SC2034
file_system_err=6

# mounting disks
# shellcheck disable=SC2034
mount_err=7

# initial home population with skeleton directory
home_populate_err=8

# when changing user home permissions
change_home_perm_err=9


rw_base_home() {
	echo "$rw_dir/${base_home_dir#/}"
}

fill_skeleton_directory() {
	cp -r "$skel_dir" "$(rw_base_home)"/"$user"
}

fix_user_dir_permission() {
	chown -R "$user":"$user" "$(rw_base_home)"/"$user"
}

populate_home_dir() {
	mkdir -p "$(rw_base_home)"

	if ! exec_log "populate home directory from: $skel_dir" \
		fill_skeleton_directory; then

		return "$home_populate_err"
	fi

	if ! exec_log "fix home user dir permissions" \
		fix_user_dir_permission; then

		return "$change_home_perm_err"
	fi
}

handle_user_data_created() {
	:
}

# configures default files on client disk
setup_vm_user_data() {
	local exit_status
	exit_status=0

	# create user home directory
	if [ ! -d "$(rw_base_home)" ]; then
		populate_home_dir
		exit_status="$?"

		if [ "$exit_status" -ne 0 ]; then
			return "$exit_status"
		fi

		handle_user_data_created
	fi

	# configuration files
	# gives user full control over the installation
	mkdir -p "$rw_dir"/config/
	mkdir -p "$rw_dir"/binds/

	if [ ! -f "$rw_dir"/config/rc.local ]; then
		cat <<EOF > "$rw_dir"/config/rc.local
#!$default_binary
# Put commands to execute with systemd service.
# Eg.: systemctl start openvpn-client
EOF
		chmod 755 "$rw_dir"/config/rc.local
	fi

	if [ ! -f "$rw_dir"/config/bind-dirs.manifest ]; then
		touch "$rw_dir"/config/bind-dirs.manifest
		chmod 644 "$rw_dir"/config/bind-dirs.manifest
	fi
}

# try to resolve a path to it's real path
# 
# it may not be able to deliver when the link 
# level is too high. in order to address this problem, 
# one may specify as second argument the maximum depth 
maybe_resolve_symlink_path() {
	local path max_depth symlink_level_counter real_path

	path="$1"
	max_depth="${2:-15}"
	symlink_level_counter="0"

	while [ -h "$path" ] && [ "$symlink_level_counter" -lt "$max_depth" ]; do
		real_path="$(realpath "$path")"
		path="$real_path"
		symlink_level_counter="$(( symlink_level_counter + 1 ))"
	done

	echo "$path"
}

is_directory_bind() {
	local sufix_transform="/${1#/}"
	local sufix_and_prefix="${sufix_transform%/}/"

	grep -e "^$sufix_transform$" -e "^$sufix_and_prefix$" \
		"$rw_dir"/config/bind-dirs.manifest > /dev/null 2>&1
}

# given a root directory, mount every file to the root filesystem
#
# imagine the following file structure:
# /rw/binds
# └── etc
#     └── wireguard
#         └── wg0.conf
#
# now, the file /rw/binds/etc/wireguard/wg0.conf would be
# mounted at /etc/wireguard/wg0.conf
# 
bind_files() {
	for file in "$1"/*; do
		# avoid an infinite loop
		if [ -z "$file" ]; then
			break
		fi

		local path="${1%/}/$file"
		local should_bind=true
		
		if [ -d "$path" ]; then
			local fake_path="${path#${rw_dir}/binds}"
			
			if ! is_directory_bind "$fake_path"; then
				# will ignore this current file		
				should_bind=false

				# recursive function call when path is a directory
				# and is not registered as a bind
		    	bind_files "$path"
			fi
		fi

		$should_bind && local_bind_file_object "$path"
	done
}

local_bind_file_object() {
	local path="$1"

	# try to find the real path
	real_path="$(maybe_resolve_symlink_path "$path")"
	
	# is it still a symlink? skip
	if [ -h "$real_path" ]; then
		echo "[-] $0: symbolic link is too depth: $path"
		return 1
	fi

	# find the target path to file
	local target_file="${real_path#$rw_dir/binds}"

	# ensure it is an absolute path to the filesystem
	target_file="/${target_file#/}"

	# backup existing content and ensure target_file
	# is not present
	if [ -e "$target_file" ]; then
		exec_log "backup existing target: $target_file" \
			mv --force "$target_file" "${target_file%/}.old" || return "$file_system_err"
	fi

	# call arbitrary mount function to create link
	# between source and target
	mount_strategy "$real_path" "$target_file"
}

# execute this at startup
start_user_custom_config() {
	bind_files "$rw_dir"/binds
	"$rw_dir"/config/rc.local
}

is_template_vm() {
	if [ "$1" -lt 2 ]; then
		info "seems like the template vm here, aborting..."
		return 0
	fi

	return 1
}

info() {
	echo "$(date) [INFO] $*"
}

err() {
	echo "$(date) [ERROR] $*" >> /dev/stderr
}

exec_log() {
	local exit_status title fn text
	title="$1"
	fn=$2
	shift
	shift

	text="$title [$fn $*]"

	# call function
	$fn "$@"
	exit_status="$?"

	if [ "$exit_status" -eq 0 ]; then
		info "$text: succeded"
	else
		err "$text: failed"
	fi

	return "$exit_status"
}