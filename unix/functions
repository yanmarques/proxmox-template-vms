#!/bin/sh

# shellcheck shell=bash

unset user rw_dir

#################################################
# Environment vars
#################################################

# rw directorty var
rw_dir=${TEMPLATED_RW_DIR:-/rw}
rw_dir=${rw_dir%/}

# where log to
log_file="${TEMPLATED_LOG_FILE:-/var/log/templated.log}"

# skeleton directory for user
skel_dir=${TEMPLATED_SKEL_DIR:-/etc/skel}
skel_dir=${skel_dir%/}

# base home directory
base_home_dir=${TEMPLATED_BASE_HOME_DIR:-/home}
base_home_dir=${base_home_dir%/}

# global vars
openbsd_dev="${TEMPLATE_OPENBSD_DEV:-sd0}"
# linux_dev="${TEMPLATE_LINUX_DEV:-sda}"


rw_base_home() {
	echo "$rw_dir/${base_home_dir#/}"
}

openbsd_disks_count() {
	sysctl hw.disknames | tr ',' '\n' | egrep '(sd|wd)[0-9]{1}\:' | wc -l
}

# linux_disks_count() {
# 	fdisk -l | egrep 'Disk /dev/(sd|hd)[a-z]{1}' | wc -l
# }

# linux_start_disk() {
# 	local device="$1"
# 	local user="$2"

# 	# block device path
# 	local block_dev=/dev/"$device"

# 	# path to disk partition
# 	local block_dev_partition="$block_dev"1

# 	# is the block device already formatted?
# 	# no, so format it and configure it's contents
# 	if ! blkid "$block_dev" > /dev/null; then
# 		# create MBR partition table and one partition with the whole disk
# 		# of the type 83 in hexcode, which means Linux type  
# 		echo 'type=83' | sfdisk "$block_dev"

# 		# create an ext4 file system on the created partition
# 		mkfs.ext4 "$block_dev_partition"
# 	fi

# 	# ensure mountpoiunt exists then mount
# 	mkdir -p /rw/
# 	mount "$block_dev_partition" /rw/

# 	setup_vm_disk /bin/bash "$user"
# }

openbsd_start_disk() {
	# represents an empty disk uid
	local empty_duid="0000000000000000"

	local device="$1"
	local user="$2"
	
	# whole disk
	local char_dev_disk=/dev/r"$device"c

	# root partition
	local char_dev_root=/dev/r"$device"a
	
	# block device
	local block_dev_root=/dev/"$device"a

	# grab device uid
	local duid="$(disklabel $device | grep duid | awk -F: '{print $2}' | tr -d ' ')"

	# deduce whether disk needs a partition table initialization
	if [ "$duid" == "$empty_duid" ]; then
		# create fdisk partition and MBR partition table
		fdisk -iy "$char_dev_disk"

		# create partition
		disklabel -Aw "$char_dev_disk"
		
		# create file system
		newfs "$char_dev_root"
	fi

	# ensure mountpoint exists and mount
	mkdir -p "$rw_dir"/
	mount "$block_dev_root" "$rw_dir"/

	setup_vm_disk /bin/ksh "$user"
}

openbsd_main() {
	local user="$1"

	# configure disk and mountpoints
	openbsd_start_disk "$openbsd_dev" "$user"

	# is home mounted then umount
	if df -P | grep "$base_home_dir"; then
		umount "$base_home_dir"
	else
		# make a backup of "$base_home_dir"
		mv "$base_home_dir" "$base_home_dir".old

		# recreate base home directory
		mkdir -m 700 "$base_home_dir"
	fi
	
	# bind user home
	ln -s "$(rw_base_home)"/* "$base_home_dir"
}

# linux_main() {
# 	local user="$1"

# 	linux_start_disk "$linux_dev" "$user"

# 	# make a transparent bind for user's home
# 	mount --bind /rw/home/ /home/
# }

# configures default files on client disk
setup_vm_disk() {
	local binary="$1"

	# create user home directory
	if [ ! -d "$(rw_base_home)" ]; then
		mkdir -p "$(rw_base_home)"

		if ! exec_log "populate home directory from: $skel_dir" \
			cp -r "$skel_dir" "$(rw_base_home)"/"$user"; then

			exit 5
		fi

		if ! exec_log "set home user permission" \
			chown -R "$user":"$user" "$(rw_base_home)"/"$user"; then

			exit 6
		fi

		# maybe restore SELinux security context
		if command -v restorecon > /dev/null 2>&1; then
			restorecon -R "$(rw_base_home)"
		fi
	fi

	# configuration files
	# gives user full control over the installation
	mkdir -p "$rw_dir"/config/
	mkdir -p "$rw_dir"/binds/

	if [ ! -f "$rw_dir"/config/rc.local ]; then
		cat <<EOF > "$rw_dir"/config/rc.local
#!$binary
# Put commands to execute with systemd service.
# Eg.: systemctl start openvpn-client
EOF
		chmod 755 "$rw_dir"/config/rc.local
	fi

	if [ ! -f "$rw_dir"/config/bind-dirs.manifest ]; then
		touch "$rw_dir"/config/bind-dirs.manifest
		chmod 644 "$rw_dir"/config/bind-dirs.manifest
	fi
}

# try to resolve a path to it's real path
# 
# it may not be able to deliver when the link 
# level is too high. in order to address this problem, 
# one may specify as second argument the maximum depth 
maybe_resolve_symlink_path() {
	local path max_depth symlink_level_counter real_path

	path="$1"
	max_depth="${2:-15}"
	symlink_level_counter="0"

	while [ -h "$path" ] && [ "$symlink_level_counter" -lt "$max_depth" ]; do
		real_path="$(realpath "$path")"
		path="$real_path"
		symlink_level_counter="$(( symlink_level_counter + 1 ))"
	done

	echo "$path"
}

is_directory_bind() {
	local sufix_transform="/${1#/}"
	local sufix_and_prefix="${sufix_transform%/}/"

	grep -e "^$sufix_transform$" -e "^$sufix_and_prefix$" \
		"$rw_dir"/config/bind-dirs.manifest > /dev/null 2>&1
}

# given a root directory, mount every file to the root filesystem
#
# imagine the following file structure:
# /rw/binds
# └── etc
#     └── wireguard
#         └── wg0.conf
#
# now, the file /rw/binds/etc/wireguard/wg0.conf would be
# mounted at /etc/wireguard/wg0.conf
# 
bind_files() {
	for file in $(ls "$1"); do
		# avoid an infinite loop
		if [ -z "$file" ]; then
			break
		fi

		local path="${1%/}/$file"
		local should_bind=true
		
		if [ -d "$path" ]; then
			local fake_path="${path#${rw_dir}/binds}"
			
			if ! is_directory_bind "$fake_path"; then
				# will ignore this current file		
				should_bind=false

				# recursive function call when path is a directory
				# and is not registered as a bind
		    	bind_files "$path"
			fi
		fi

		$should_bind && local_bind_file_object "$path"
	done
}

local_bind_file_object() {
	local path="$1"

	# try to find the real path
	real_path="$(maybe_resolve_symlink_path "$path")"
	
	# is it still a symlink? skip
	if [ -h "$real_path" ]; then
		echo "[-] $0: symbolic link is too depth: $path"
		continue
	fi

	# find the target path to file
	local target_file="${real_path#$rw_dir/binds}"

	# ensure it is an absolute path to the filesystem
	target_file="/${target_file#/}"

	# ensure directory exists
	mkdir -p "$(dirname $target_file)"

	# backup existing content and ensure target_file
	# is not present
	if [ -e "$target_file" ]; then
		mv --force "$target_file" "${target_file%/}.old"
	fi

	# create a symbolic link
	ln -s "$real_path" "$target_file"
}

# execute this at startup
handle_user_config() {
	bind_files "$rw_dir"/binds
	"$rw_dir"/config/rc.local
}

on_template_or_out() {
	if [ "$1" -lt 2 ]; then
		info "seems like the template vm here, aborting..."
		exit 0
	fi
}

info() {
	echo "$(date) [INFO] $@"
}

err() {
	echo "$(date) [ERROR] $@" > /dev/stderr
}

exec_log() {
	local title="$1"
	local fn=$2
	shift
	shift
	local args=$*

	local text="$title [$args]"

	if $fn "$args"; then
		info "$text: succeded"
		return 0
	fi

	err "$text: failed"
	return 1
}

templated_exec() {
	local main log

	# input argument
	start_fn=$1
	
	# set global user
	user="$2"

	{
		info "starting templated main function"
		$start_fn
		handle_user_config
	} >> "$log_file" 2>&1
}
