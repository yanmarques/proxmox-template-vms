#!/bin/sh

# shellcheck shell=bash

unset user rw_dir

#################################################
# Environment vars
#################################################

# rw directorty var
rw_dir=${TEMPLATED_RW_DIR:-/rw}
rw_dir=${rw_dir%/}

# where log to
log_file="${TEMPLATED_LOG_FILE:-/var/log/templated.log}"

# skeleton directory for user
skel_dir=${TEMPLATED_SKEL_DIR:-/etc/skel}
skel_dir=${skel_dir%/}

# base home directory
base_home_dir=${TEMPLATED_BASE_HOME_DIR:-/home}
base_home_dir=${base_home_dir%/}


#################################################
# Error codes
#################################################

# operations on formating a raw disk
# shellcheck disable=SC2034
format_disk_err=5

# file system creation
# shellcheck disable=SC2034
file_system_err=6

# mounting disks
# shellcheck disable=SC2034
mount_err=7

# initial home population with skeleton directory
home_populate_err=8

# when changing user home permissions
change_home_perm_err=9


rw_base_home() {
	echo "$rw_dir/${base_home_dir#/}"
}

# configures default files on client disk
setup_vm_disk() {
	local binary="$1"

	# create user home directory
	if [ ! -d "$(rw_base_home)" ]; then
		mkdir -p "$(rw_base_home)"

		if ! exec_log "populate home directory from: $skel_dir" \
			cp -r "$skel_dir" "$(rw_base_home)"/"$user"; then

			return "$home_populate_err"
		fi

		if ! exec_log "set home user owner perm" \
			chown -R "$user" "$(rw_base_home)"/"$user"; then

			return "$change_home_perm_err"
		fi

		if ! exec_log "set home user group perm" \
			chgrp -R "$user" "$(rw_base_home)"/"$user"; then

			return "$change_home_perm_err"
		fi

		# maybe restore SELinux security context
		if command -v restorecon > /dev/null 2>&1; then
			restorecon -R "$(rw_base_home)"
		fi
	fi

	# configuration files
	# gives user full control over the installation
	mkdir -p "$rw_dir"/config/
	mkdir -p "$rw_dir"/binds/

	if [ ! -f "$rw_dir"/config/rc.local ]; then
		cat <<EOF > "$rw_dir"/config/rc.local
#!$binary
# Put commands to execute with systemd service.
# Eg.: systemctl start openvpn-client
EOF
		chmod 755 "$rw_dir"/config/rc.local
	fi

	if [ ! -f "$rw_dir"/config/bind-dirs.manifest ]; then
		touch "$rw_dir"/config/bind-dirs.manifest
		chmod 644 "$rw_dir"/config/bind-dirs.manifest
	fi
}

# try to resolve a path to it's real path
# 
# it may not be able to deliver when the link 
# level is too high. in order to address this problem, 
# one may specify as second argument the maximum depth 
maybe_resolve_symlink_path() {
	local path max_depth symlink_level_counter real_path

	path="$1"
	max_depth="${2:-15}"
	symlink_level_counter="0"

	while [ -h "$path" ] && [ "$symlink_level_counter" -lt "$max_depth" ]; do
		real_path="$(realpath "$path")"
		path="$real_path"
		symlink_level_counter="$(( symlink_level_counter + 1 ))"
	done

	echo "$path"
}

is_directory_bind() {
	local sufix_transform="/${1#/}"
	local sufix_and_prefix="${sufix_transform%/}/"

	grep -e "^$sufix_transform$" -e "^$sufix_and_prefix$" \
		"$rw_dir"/config/bind-dirs.manifest > /dev/null 2>&1
}

# given a root directory, mount every file to the root filesystem
#
# imagine the following file structure:
# /rw/binds
# └── etc
#     └── wireguard
#         └── wg0.conf
#
# now, the file /rw/binds/etc/wireguard/wg0.conf would be
# mounted at /etc/wireguard/wg0.conf
# 
bind_files() {
	for file in "$1"/*; do
		# avoid an infinite loop
		if [ -z "$file" ]; then
			break
		fi

		local path="${1%/}/$file"
		local should_bind=true
		
		if [ -d "$path" ]; then
			local fake_path="${path#${rw_dir}/binds}"
			
			if ! is_directory_bind "$fake_path"; then
				# will ignore this current file		
				should_bind=false

				# recursive function call when path is a directory
				# and is not registered as a bind
		    	bind_files "$path"
			fi
		fi

		$should_bind && local_bind_file_object "$path"
	done
}

local_bind_file_object() {
	local path="$1"

	# try to find the real path
	real_path="$(maybe_resolve_symlink_path "$path")"
	
	# is it still a symlink? skip
	if [ -h "$real_path" ]; then
		echo "[-] $0: symbolic link is too depth: $path"
		return 1
	fi

	# find the target path to file
	local target_file="${real_path#$rw_dir/binds}"

	# ensure it is an absolute path to the filesystem
	target_file="/${target_file#/}"

	# ensure directory exists
	mkdir -p "$(dirname "$target_file")"

	# backup existing content and ensure target_file
	# is not present
	if [ -e "$target_file" ]; then
		mv --force "$target_file" "${target_file%/}.old"
	fi

	# create a symbolic link
	ln -s "$real_path" "$target_file"
}

# execute this at startup
handle_user_config() {
	bind_files "$rw_dir"/binds
	"$rw_dir"/config/rc.local
}

is_template_vm() {
	if [ "$1" -lt 2 ]; then
		info "seems like the template vm here, aborting..."
		return 0
	fi

	return 1
}

info() {
	echo "$(date) [INFO] $*"
}

err() {
	echo "$(date) [ERROR] $*" >> /dev/stderr
}

exec_log() {
	local title="$1"
	local fn=$2
	shift
	shift

	local text="$title [$fn $*]"

	if $fn "$@"; then
		info "$text: succeded"
		return 0
	fi

	err "$text: failed"
	return 1
}

templated_exec() {
	local start_fn 

	# input argument
	start_fn=$1
	
	# set global user
	user="$2"

	if [ -z "$2" ]; then
        echo "Usage: maybe-start-templated-vm USER"
        return 1
    fi

	{
		info "starting templated main function"
		$start_fn
		handle_user_config
	} >> "$log_file" 2>&1
}
