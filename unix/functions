#!/bin/sh

# shellcheck shell=bash

unset user

#################################################
# Environment vars
#################################################

# rw directorty var
rw_dir=${TEMPLATED_RW_DIR:-/rw}
rw_dir=${rw_dir%/}

# skeleton directory for user
skel_dir=${TEMPLATED_SKEL_DIR:-/etc/skel}
skel_dir=${skel_dir%/}

# base home directory
base_home_dir=${TEMPLATED_BASE_HOME_DIR:-/home}
base_home_dir=${base_home_dir%/}

# default binary used on rc script
default_binary=${TEMPLATED_BINARY:-/bin/bash}
default_binary=${base_home_dir%/}

# default runtime path where host data is stored
runtime_dir=${TEMPLATED_RUNTIME_DIR:-/var/run/proxmox-templated-vms}
runtime_dir=${runtime_dir%/}

# default disk used to receive host information
default_host_cdrom=${TEMPLATED_HOST_CDROM:-/dev/sr0}


#################################################
# Error codes
#################################################

# operations on formating a raw disk
# shellcheck disable=SC2034
format_disk_err=5

# file system creation
# shellcheck disable=SC2034
file_system_err=6

# mounting disks
# shellcheck disable=SC2034
mount_err=7

# initial home population with skeleton directory
home_populate_err=8

# when changing user home permissions
change_home_perm_err=9

rw_base_home() {
	# user home directory location on rw device
	echo "$rw_dir"/home
}

fill_skeleton_directory() {
	# shellcheck disable=SC2154
	cp -a "$skel_dir" "$(rw_base_home)"/"$user"
}

fix_user_dir_permission() {
	chown -R "$user" "$(rw_base_home)"/"$user" && \
		chgrp -R "$user" "$(rw_base_home)"/"$user"
}

populate_home_dir() {
	mkdir -p "$(rw_base_home)"

	exec_log "populate home directory from: $skel_dir" \
		fill_skeleton_directory || return "$home_populate_err"

	exec_log "fix home user dir permissions" \
		fix_user_dir_permission || return "$change_home_perm_err"
}

post_home_dir_populated() {
	:
}

# configures default files on client disk
setup_vm_user_data() {
	# create user home directory
	if [ ! -d "$(rw_base_home)" ]; then
		exec_log "home directory initialization" \
			populate_home_dir || return

		exec_log "calling post-home-dir-populated hook" \
			post_home_dir_populated || return
	fi

	# configuration files
	# gives user full control over the installation
	mkdir -p "$rw_dir"/config/
	mkdir -p "$rw_dir"/binds/

	if [ ! -f "$rw_dir"/config/rc.local ]; then
		cat <<EOF > "$rw_dir"/config/rc.local
#!$default_binary
# Put commands to execute with systemd service.
# Eg.: systemctl start openvpn-client
EOF
		chmod 755 "$rw_dir"/config/rc.local
	fi

	if [ ! -f "$rw_dir"/config/bind-dirs.manifest ]; then
		touch "$rw_dir"/config/bind-dirs.manifest
		chmod 644 "$rw_dir"/config/bind-dirs.manifest
	fi
}

is_directory_bind() {
	local directory sufix_transform sufix_and_prefix
	directory="${1:?}"
	sufix_transform="/${directory#/}"
	sufix_and_prefix="${sufix_transform%/}/"

	grep -e "^$sufix_transform$" -e "^$sufix_and_prefix$" \
		"$rw_dir"/config/bind-dirs.manifest > /dev/null 2>&1
}

# given a root directory, mount every file to the root filesystem
#
# imagine the following file structure:
# /rw/binds
# └── etc
#     └── wireguard
#         └── wg0.conf
#
# now, the file /rw/binds/etc/wireguard/wg0.conf would be
# mounted at /etc/wireguard/wg0.conf
# 
bind_files() {
	local target
	target="${1:?}"

	for file in "$target"/*; do
		# avoid an infinite loop
		if [ -z "$file" ]; then
			break
		fi

		local path="${target%/}/$file"
		local should_bind=true
		
		if [ -d "$path" ]; then
			local fake_path="${path#${rw_dir}/binds}"
			
			if ! is_directory_bind "$fake_path"; then
				# will ignore this current file		
				should_bind=false

				# recursive function call when path is a directory
				# and is not registered as a bind
		    	bind_files "$path"
			fi
		fi

		$should_bind && local_bind_file_object "$path"
	done
}

local_bind_file_object() {
	local path target_file
	path="${1:?}"

	# try to find the real path
	real_path="$(realpath "$path")"
	
	# ensure path exists
	if [ ! -e "$real_path" ]; then
		err "file not found: $path"
		return 1
	fi

	# find the target path to file
	target_file="${real_path#$rw_dir/binds}"

	# ensure it is an absolute path to the filesystem
	target_file="/${target_file#/}"

	# backup existing content and ensure target_file
	# is not present
	if [ -e "$target_file" ]; then
		exec_log "backup existing target: $target_file" \
			mv --force "$target_file" "${target_file%/}.old" || return "$file_system_err"
	fi

	# call arbitrary mount function to create link
	# between source and target
	exec_log "binding user file" \
		mount_strategy "$real_path" "$target_file"
}

mount_user_home_dir() {
	mount_strategy "$(rw_base_home)" "$base_home_dir"
}

# execute this at startup
start_user_custom_config() {
	exec_log "binding user files" bind_files "$rw_dir"/binds
	exec_log "calling user rc script" "$rw_dir"/config/rc.local
}

ensure_formated_and_mounted() {
	local env_device
	env_device="${TEMPLATED_DEV}"

	if [ -n "$env_device" ]; then
		start_disk "$env_device" "$@"
		return
	fi

	local uuid uuid_count disk disk_count
	uuid="$(detect_partition)"
	disk="$(detect_raw_disk)"

	# nothing detected
	if [ -z "$disk" ] && [ -z "$uuid" ]; then
		err "any raw disk or partition available"
		return "$format_disk_err"
	fi

	# count lines
	uuid_count="$(wc -l <<< "${uuid}")"
	disk_count="$(wc -l <<< "${disk}")"

	local disk_valid uuid_valid
	disk_valid=false
	uuid_valid=false

	# set whether valid
	[ -n "$disk" ] && [ "$disk_count" -eq 1 ] && disk_valid=true
	[ -n "$uuid" ] && [ "$uuid_count" -eq 1 ] && uuid_valid=true

	if ! $disk_valid && ! $uuid_valid; then
		err "can not proceed, unable to detect with precision which device to use"
		info "ensure that only exists 1 formatted partition or 1 disk"
		return "$format_disk_err"
	fi

	# takes precedence over the raw disk.
	# this is a must, because one should be able to start a template-based 
	# vm with just some raw disk and it ignores these raw disks
	if $uuid_valid; then
		start_disk_from_partition "$uuid" "$@"
		return
	fi
	
	# disk is raw, will use the first partition
	start_disk "$disk" -B "$disk"1 "$@"
}

receive_host_data() {
	if [ ! -b "$default_host_cdrom" ]; then
		err "failed to receive host data, missing cdrom disk"
		return 1
	fi 

	# ensure mountpoint exists
	mkdir -p "$runtime_dir"

	exec_log "mount host disk" mount -o ro "$default_host_cdrom" "$runtime_dir" || \
		return "$mount_err"
}

is_template_vm() {
	[ -f "$runtime_dir"/template-vm ]
}

info() {
	echo "$(date) [INFO] $*"
}

err() {
	echo "$(date) [ERROR] $*" >> /dev/stderr
}

exec_log() {
	local exit_status title fn text
	title="${1:?}"
	fn=${2:?}
	shift
	shift

	text="$title [$fn"

	# only put arguments when present
	if [ $# -ne 0 ]; then
		text+=" $*]"
	else
		text+="]"
	fi

	# call function
	$fn "$@"
	exit_status="$?"

	if [ "$exit_status" -eq 0 ]; then
		info "$text: succeded"
	else
		err "$text: failed"
	fi

	return "$exit_status"
}