#!/bin/bash

disks_counter() {
	list_scsi_disks | wc -l
}

list_scsi_disks() {
	lsblk --output PATH --scsi | sed 1d
}

is_raw_disk() {
    blkid -p "$1" > /dev/null
    [ "$?" -eq 2 ]
}

format_linux_disk() {
	# create MBR partition table and one partition with the whole disk
	# of the type 83 in hexcode, which means Linux type
	echo 'type=83' | sfdisk "$1" > /dev/null
}

make_silent_ext4_fs() {
	mkfs.ext4 "$@" > /dev/null
}

format_disk_when_raw() {
	local block_dev block_dev_partition
	block_dev="$1"
	block_dev_partition="$2"

	# allow all other arguments be passed to mkfs.ext4
	shift
	shift

	# is the block device already formatted?
	# no, so format it and configure it's contents
	if is_raw_disk "$block_dev"; then
		if ! exec_log "format block device" \
			format_linux_disk "$block_dev"; then

			# shellcheck disable=SC2154
			return "$format_disk_err"
		fi

		# create an ext4 file system on the created partition
		if ! exec_log "create fs on partition" \
			make_silent_ext4_fs "$@" "$block_dev_partition"; then

			# shellcheck disable=SC2154
			return "$file_system_err"
		fi
	fi
}

start_disk() {
	local block_dev block_dev_partition format_opts mount_opts

	# block device path
	block_dev="$1"
	shift
	
	# default path to disk partition
	block_dev_partition="$block_dev"

	while [[ "$1" == -* ]]; do
		case "$1" in
			-B)
				block_dev_partition="$2"
				;;
			--format-opts)
				format_opts="$2"
				;;
			--mount-opts)
				mount_opts="$2"
				;;
			*) ;;
		esac

		shift
		shift
	done
	
	# shellcheck disable=2086
	if ! format_disk_when_raw "$block_dev" \
		"$block_dev_partition" ${format_opts}; then

		return "$?"
	fi

	# ensure mountpoiunt exists then mount
	# shellcheck disable=SC2154
	mkdir -p "$rw_dir"

	# mount device disk on rw directory
	# shellcheck disable=2086
	if ! exec_log "mount device" \
		mount ${mount_opts} "$block_dev_partition" "$rw_dir"; then

		# shellcheck disable=SC2154
		return "$mount_err"
	fi
}

uninstalled_partitions() {
	for uuid in $(blkid -o export | grep '^UUID' | awk -F= '{print $2}'); do

		# keep the ones which are not in fstab
		if ! grep "$uuid" /etc/fstab > /dev/null; then
			echo "$uuid"
		fi
	done
}

start_from_partition() {
	local device uuid ptuuid dev_part
	uuid="$1"

	# ensure uuid is valid just getting the device path 
	dev_part="$(blkid --uuid="$uuid")"
	if [ "$?" -eq 2 ]; then
		err "no such device: $uuid"
		return 2
	fi

	# extract ptuuid from uuid
	ptuuid="$(lsblk --output UUID,PTUUID | grep "^$uuid" | awk '{print $2}')"

	# extract the first device path from ptuuid
	device="$(lsblk --output PTUUID,PATH | grep -m 1 "^$ptuuid" | awk '{print $2}')"

	start_disk "$device" -B "$dev_part" "$@"
}

detect_partition() {
	local uuid
	uuid="$(uninstalled_partitions)"

	if [ "$(wc -l "$uuid")" -gt 1 ]; then
		err "too many partitions recognized"
		return 2
	fi

	echo "$uuid"
}

detect_raw_disk() {
	local raw_disks
	raw_disks=()

	for disk in $(list_scsi_disks); do
		is_raw_disk "$disk" && raw_disks+=( "$disk" )
	done

	if [ "${raw_disks[#]}" -gt 1 ]; then
		err "too many raw devices detected"
		return 2
	fi

	echo "${raw_disks[*]}"
}

ensure_formated_and_mounted() {
	local linux_dev
	linux_dev="${TEMPLATED_DEV}"

	if [ -n "$linux_dev" ]; then
		start_disk "$linux_dev" "$@"
		return
	fi

	local uuid disk
	uuid="$(detect_partition)"
	uuid_code="$?"
	disk="$(detect_raw_disk)"
	disk_code="$?"

	if [ "$(( "$uuid_code" + "$disk_code" ))" -eq 4 ]; then
		err "can not proceed, unable to detect with precision which device to use"
		info "ensure that only exists 1 formatted partition or 1 disk"
		return "$format_disk_err"
	fi

	# takes precedence over the raw disk.
	# this is a must, because one should be able to start a template-based 
	# vm with just some raw disk and it ignores these raw disks
	if [ "$uuid_code" -eq 0 ]; then
		start_from_partition "$uuid"
		return
	fi
	
	# disk is raw, will use the first partition
	start_disk "$disk" -B "$disk"1
}

post_home_dir_populated() {
	# maybe restore SELinux security context
	if command -v restorecon > /dev/null 2>&1; then
		# shellcheck disable=SC2154
		restorecon -R "$(rw_base_home)"
	fi
}

mount_strategy() {
	local src target args mnt_opts

	src="$1"
	target="$2"
	args="$3"
	mnt_opts=

	# is not a block device, so will
	# bind mount it
	#
	# if receives a "--force-disk" argument
	# then unconditionally consider source as a disk
	if [ ! -b "$src" ] && [ ! "$args" == "--force-disk" ]; then
		mnt_opts="--bind"
	
		# mount point is not present
		if [ ! -e "$target" ]; then
			# ensure target's root directory exists
			mkdir -p "$(dirname "$target")"

			# is it a file
			if [ -f "$src" ]; then
				touch "$target"

			# is it a directory
			elif [ -d "$src" ]; then
				mkdir -p "$target"

			# alert user and hope for the best
			else
				err "target mountpoint seems to be invalid"
			fi
		fi
	fi

	mount ${mnt_opts} "$src" "$target"
}
