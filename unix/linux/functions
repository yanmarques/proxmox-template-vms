#!/bin/bash

list_scsi_disks() {
	lsblk --output PATH --scsi | sed 1d
}

list_part_uuids() {
	lsblk --output TYPE,UUID --exclude 252 | \
		grep '^part[[:space:]]' | awk '{print $2}'
}

list_all_disks() {
	# --exclude 252 (SWAP)
	lsblk --output TYPE,PATH --exclude 252 | \
		grep '^disk[[:space:]]' | awk '{print $2}'
}

is_raw_disk() {
	local disk
	disk="${1:?}"

    blkid -p "$disk" > /dev/null
    [ "$?" -eq 2 ]
}

make_filesystem() {
	local device
	device="${1:?}"

	# no reserved blocks for privileged proccesses (-m 0)
	# with journaling (-j)
	# quiet (-q)
	mkfs.ext4 -m 0 -j -q "$device"
}

prepare_disk_when_raw() {
	local block_dev
	block_dev="${1:?}"

	# is the block device already formatted?
	# no, so format it and configure it's contents
	if ! is_raw_disk "$block_dev"; then
		return 0
	fi

	# create an ext4 file system on the created partition
	# shellcheck disable=SC2154
	exec_log "create fs on device" make_filesystem "$block_dev" || \
		return "$file_system_err"
}

fix_ext4_fs() {
	local device
	device="${1:?}"

	# try to fix file system
	exec_log "private device mgmt" fsck.ext4 -p "$device"
}

start_disk() {
	local block_dev

	# block device path
	block_dev="${1:?}"
	
	# shellcheck disable=2086
	prepare_disk_when_raw "$block_dev" || return

	# device mgmt
	fix_ext4_fs "$block_dev" || return

	# ensure mountpoiunt exists then mount
	# shellcheck disable=SC2154
	mkdir -p "$rw_dir"

	# mount device disk on rw directory
	# shellcheck disable=2086
	# shellcheck disable=SC2154
	exec_log "mount device" \
		mount "$block_dev" "$rw_dir" || \
		return "$mount_err"
}

uninstalled_partitions() {
	# shellcheck disable=SC2154
	for uuid in $(list_part_uuids | grep -v "$templated_disk_uuid"); do

		# keep the ones which are not in fstab
		! grep "$uuid" /etc/fstab > /dev/null && echo "$uuid"
	done
}

start_disk_from_partition() {
	local device uuid ptuuid dev_part
	uuid="${1:?}"

	# ensure uuid is valid just getting the device path 
	dev_part="$(find_device_by_uuid "$uuid")"
	if [ "$?" -eq 2 ]; then
		err "no such device: $uuid"
		return 2
	fi

	# extract ptuuid from uuid
	ptuuid="$(lsblk --output UUID,PTUUID | grep "^$uuid" | awk '{print $2}')"

	# extract the first device path from ptuuid
	device="$(lsblk --output PTUUID,PATH | grep -m 1 "^$ptuuid" | awk '{print $2}')"

	start_disk "$device" -B "$dev_part" "$@"
}

find_device_by_uuid() {
	local uuid status_code
	uuid="${1:?}"

	disk=$(blkid --uuid="$uuid")
	status_code="$?"
	
	if [ "$status_code" -eq 0 ]; then
		echo "$disk"
		return 0
	fi

	if [ "$status_code" -eq 2 ]; then
		err "no such partition: $uuid"
		return 2
	fi

	return "$status_code"
}

detect_partition() {
	uninstalled_partitions
}

detect_raw_disk() {
	for disk in $(list_all_disks); do
		is_raw_disk "$disk" && echo "$disk"
	done
}

post_home_dir_populated() {
	# maybe restore SELinux security context
	if command -v restorecon > /dev/null 2>&1; then
		# shellcheck disable=SC2154
		restorecon -R "$(rw_base_home)"
	fi
}

mount_strategy() {
	local src target args mnt_opts

	src="${1:?}"
	target="${2:?}"
	args="$3"
	mnt_opts=

	# is not a block device, so will
	# bind mount it
	#
	# if receives a "--force-disk" argument
	# then unconditionally consider source as a disk
	if [ ! -b "$src" ] && [ ! "$args" == "--force-disk" ]; then
		mnt_opts="--bind"
	
		# mount point is not present
		if [ ! -e "$target" ]; then
			# ensure target's root directory exists
			mkdir -p "$(dirname "$target")"

			# is it a file
			if [ -f "$src" ]; then
				touch "$target"

			# is it a directory
			elif [ -d "$src" ]; then
				mkdir -p "$target"

			# alert user and hope for the best
			else
				err "target mountpoint seems to be invalid"
			fi
		fi
	fi

	mount ${mnt_opts} "$src" "$target"
}
